library(mvtnorm)
library(tidyverse)
### 2-2-7: Implementaciones propias de la T_{p, k} "central"  y "no-central"
rmvt_ <- function(n, k, mu=rep(0, nrow(Sigma)), Sigma=diag(length(mu))) {
  p <- length(mu)
  C <- chol(Sigma) # devuelve la triangular SUPERIOR : C'C=Sigma
  v <- k/rchisq(n, df = k)
  Z <- rmvnorm(n, mean = rep(0, p), sigma = diag(p))
  return(rep(1, n)%*%t(mu) # matrix de n*p con todas las filas = mu
         + sqrt(v) * Z %*% C) # multiplica c/fila de Z por c/ elemento de sqrt(v)
}

rmvt_2 <- function(n, k, mu=rep(0, nrow(Sigma)), Sigma=diag(length(mu))) {
  v <- k/rchisq(n, df = k)
  Z <- rmvnorm(n, sigma = Sigma)
  return(rep(1, n)%*%t(mu)
         + Z * sqrt(v)) # multiplica c/fila de Z por c/ elemento de sqrt(v)
}
# rep(1, n)%*%t(vector) + matriz == sweep(matriz, 2, vector, "+")

#### Comparacion de métodos
ntest <- 100000
Sigma <- rbind(
  c(5, 0, 2),
  c(0, 5, 1),
  c(2, 1, 2))
mu <- c(-1, 2, -3)
k <- 5

ts <- list(
  "KShirsagar" = rmvt(n=ntest, sigma=Sigma, df=k, delta=mu, type="Kshirsagar"),
  "shifted" = rmvt(n=ntest, sigma=Sigma, df=k, delta=mu, type="shifted"),
  "propia_chol" = rmvt_(n=ntest, k=k, mu=mu, Sigma=Sigma),
  "propia_directa" = rmvt_2(n=ntest, k=k, mu=mu, Sigma=Sigma)
)

map(ts, cov)
map(ts, ~apply(.,2, mean))

## 2-2-9: Test de Hotelling para muestras T-multivariadas

# Las funciones `ayudante_` están preparadas para usar `mapX` concisamente
ayudante_muestra_normal <- function(n, p, mu=rep(0, p), Sigma=diag(p)) {
  rmvnorm(n, mu, Sigma)
}

ayudante_muestra_t <- function(n, p, k, mu=rep(0, p), Sigma=diag(p)) {
  rmvt(n, Sigma, k, mu, "shifted")
}

# Se computa sin la raíz, que nunca usamos.
# https://en.wikipedia.org/wiki/Mahalanobis_distance
distancia_mahalanobis <- function(x, mu, Sigma) {
  as.double(t(x - mu) %*% solve(Sigma) %*% (x - mu))
}

ayudante_MD_muestral <- function(X, mu0=rep(0,ncol(X))) {
  x_ <- apply(X, 2, mean)
  S <- cov(X)
  distancia_mahalanobis(x_, mu0, S)
}

TIPO_COLS <- cols(
  k = col_integer(),
  p = col_integer(),
  n = col_integer(),
  tipo = col_character(),
  q = col_integer(),
  rechazos = col_integer()
)
simular <- function(rango_k, rango_n, rango_p, alfa, nsims=NULL, nbatch=500,
                      archivo='out.csv') {
  sims_ <- 0
  done <- FALSE
  
  unir_resultados <- function(nuevo) {
    actual <- if (file.exists(archivo)) {
      read_csv(archivo, col_types=TIPO_COLS)
    } else { NULL }
    bind_rows(actual, nuevo) %>%
      group_by(k, p, n, tipo) %>%
      summarise_at(c("q", "rechazos"), sum) %>%
      write_csv(archivo)
  }
  
  while (!done) {
    print(paste("Simulaciones totales:", sims_))
    cross_df(list(
      k = rango_k,
      p = rango_p,
      n = rango_n,
      nsim = seq.int(nbatch))) %>%
      mutate(
        Xmvt = pmap(list(n, p, k), ayudante_muestra_t),
        Xmvnorm = map2(n, p, ayudante_muestra_normal)) %>%
      gather("tipo", "muestra", -k, -n, -p, -nsim) %>%
      mutate(
        md = map_dbl(muestra, ayudante_MD_muestral),
        Fobs = (n-p)*n/(p*(n-1))*md,
        p_valor = pf(Fobs, df1 = p, df2 = (n-p))) %>%
      group_by(k, p, n, tipo) %>%
      summarise(
        q = n(),
        rechazos = sum(p_valor < alfa)) %>%
      unir_resultados()
    
    sims_ <- sims_ + nbatch
    if (!is.null(nsims) && (sims_ > nsims)) { done <- TRUE }
  }
}

bootstrap_test <- function(X, mu0=rep(0, ncol(X)), nboot=1000) {
  # X: matriz muestral (n*p), con 1 obs/fila
  # mu0: define H_0: mu=mu0
  # No conozco la distrib de las x_i, asumo que son normales
  # para el bootstrap
  MD <- ayudante_MD_muestral(X, mu0)
  nmuestral <- nrow(X)
  x_ <- apply(X, 2, mean)
  S <- cov(X)
  # No hace falta guardar el estadistico exacto, solo lo que cambia,
  # es decir, la distancia de Mahalanobis al cuadrado
  MDboot <- vector("numeric", nboot)
  for (i in seq.int(nboot)) {
    # Bajo H0, las observaciones tienen media mu0
    Xboot <- rmvnorm(nmuestral, mean=mu0, sigma=S)
    MDboot[i] <- ayudante_MD_muestral(Xboot, mu0)
  }
  return(list(
    x_ = x_,
    S = S,
    MD = MD,
    #MDboot = MDboot,
    p_valor = sum(MDboot > MD)/(nboot+1)))
}


mz_sim_aleatoria <- function(d) {
  m <- matrix(runif(d^2, -2, 2), ncol=d, nrow = d)
  return(m%*%t(m))
}
mz_sim_aleatoria(3)
nsims <- 1
nboot <- 100
nmuestral <- 30
k <- 3
p <- 3
#Sigmaboot <- diag(p)
Sigmaboot <- mz_sim_aleatoria(p)

alejar <- function(dim, long) {
  rep(long/sqrt(dim), dim)
}

list(
  muestras = list(
    normal = rmvnorm(nmuestral, sigma = Sigma1),
    student = rmvt(nmuestral, sigma = Sigma1, type = "shifted")
  ),
  
muestras <- tibble(
  p = c(1, 2, 4, 10),
  identidad = map(p, diag),
  aleatorio = map(p, mz_sim_aleatoria)) %>%
  gather("tipo_sigma", "sigma", -p) %>%
  mutate(
    normal = map(sigma, ~rmvnorm(nmuestral, sigma = .x)),
    student = map(sigma, ~rmvt(nmuestral, sigma = .x, df = k, type = "shifted"))) %>%
  select(-sigma) %>%
  gather("tipo_muestra", "muestra", -p, -tipo_sigma)

crossing(
  muestras,
  alejamiento = c(0.3, 1, 3, 10, 30)) %>%
  mutate(
    mu0 = map2(p, alejamiento, alejar),
    boot_call = map2(muestra, mu0, bootstrap_test, nboot = nboot),
    p_valor = map_dbl(boot_call, "p_valor"))

#   rango_dist = c(0.3, 1, 3, 10, 30)
# )) %>%
#   mutate(
#     Xnorm = rmvnorm(nmuestral, sigma = Sigma1)
#   )
# resboot <- tibble(
#   norm_est = replicate(nsims, rmvnorm(nmuestral, sigma = diag(p)), simplify=F),
#   norm_noest = replicate(nsims, rmvnorm(nmuestral, sigma = Sigma1), simplify=F),
#   t_est = replicate(nsims, rmvt(nmuestral, sigma = diag(p), k), simplify = F),
#   t_noest = replicate(nsims, rmvt(nmuestral, sigma = Sigma1, k), simplify = F)
# ) %>%
#   gather("tipo", "muestra") %>%
#   transmute(
#     tipo,
#     boot_call = map(muestra, bootstrap_test, nboot=nboot),
#     p_valor = map_dbl(boot_call, "p_valor"))
# 
# resboot %>%
#   group_by(tipo) %>%
#   summarise(
#     media = mean(p_valor),
#     varianza = var(p_valor))
#   )
# resboot %>%
#   ggplot(aes(p_valor, color = factor(tipo))) +
#   geom_density()
